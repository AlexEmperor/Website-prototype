namespace WEBtest
{
    public class Tutorial
    {

        #region ASP.NET Core

        /*
         ASP.NET MVC предназначен для создания веб-приложений с пользовательским интерфейсом. 
        Контроллеры в MVC обычно возвращают представления (View) в виде HTML-страниц, 
        которые отображаются в браузере. MVC подходит для приложений, 
        где результатом HTTP-запроса является сгенерированная HTML-разметка.

        ASP.NET Web API создан для разработки RESTful веб-сервисов,
        которые предоставляют данные клиентам в структурированном формате, чаще всего JSON или XML.
        Контроллеры Web API не возвращают HTML, а только данные и HTTP-статусы (например, 200, 404).
        Это делает Web API удобным для поддержки разнообразных клиентов — веб-приложений, 
        мобильных приложений, десктопных программ.

        Таким образом, выбор между MVC и Web API зависит от задачи: 
        если нужно создать веб-сайт с интерфейсом — MVC, 
        если требуется создать API для обмена данными с разными клиентами — Web API.
         */


        //MVC — Model-View-Controller ("Модель — Представление (Вид) — Контроллер") — схема разделения данных
        //приложения и управляющей логики на три отдельных компонента: модель, представление и контроллер.




        //Структура приложения
        //В файле \Properties\launchSetting.json находятся профили запуска нашего приложения.

        //Для запуска нашего приложения через Kestrel (Microsoft.AspNetCore.Server.Kestrel)
        //мы будем использовать профиль "https".
        //Kestrel представляет собой http-сервер, который идет вместе с ASP.NET Core
        //и предоставляет возможность запускать приложение в рамках собственного процесса.

        // Параметр "applicationUrl" в профиле "https" содержит строку URL-адреса запроса и номер порта,
        // с которыми будет произведен запуск приложения.При необходимости номер порта может быть изменен.

        /*
         В папке \wwwroot по соглашению находятся все статические файлы проекта.
        К статическим файлам относятся файлы сторонних библиотек, картинок,
        js-скриптов, css-файлов стилей, pdf-файлов и т.п.

        В папке \Controllers по соглашению создаются классы контроллеров. 

        В папке \Models по соглашению создаются классы моделей, которые мы будем использовать для хранения данных. 

        В папке \Views по соглашению создаются представления для отображения данных.
         */

        /*var builder = WebApplication.CreateBuilder(args);

        // Add services to the container.
        builder.Services.AddControllersWithViews();

        var app = builder.Build();

                app.UseHttpsRedirection();

        app.UseRouting();

        app.MapStaticAssets();

        app.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}")
            .WithStaticAssets();

                app.Run();*/

        /*
         Разберем данный листинг кода по строкам.

        В этой строке происходит создание объекта для настройки веб-приложения:
        var builder = WebApplication.CreateBuilder(args);

        В этой строке кода возможность использовать контроллеры и представления:
        builder.Services.AddControllersWithViews();

        В этой строке создаётся само веб-приложение:
        var app = builder.Build();

        В этой строке автоматически перенаправляем все HTTP запросы на HTTPS (с незащищенного соединения на защищенное):
        app.UseHttpsRedirection();

        В этой строке подключается маршрутизация запросов. С помощью UseRouting добавляется Routing, где по заданному правилу (шаблону маршрутизации) определяется правило обработки запросов:
        app.UseRouting();

        В этой строке подключается использование статических файлов, которые расположены в папке \wwwroot, то есть появляется возможность использовать файлы картинок, js-скриптов, css-стилей, текста и других файлов из этой папки в своем проекте:
        app.MapStaticAssets();

        В следующих строках кода идет подключение и настройка шаблона маршрутизации для определения маршрутов в Routing:
        app.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}")
            .WithStaticAssets();
        Метод WithStaticAssets() связывает маршрутизацию со статическими файлами.  Это современное улучшение, которое помогает системе маршрутизации быстрее определять, является ли запрос запросом к статическому файлу (например, /css/site.css) или к динамической странице. Это позволяет избежать лишней работы и немного ускоряет приложение.

        В этой строке производится запуск веб-приложения:

        app.Run();
         */


        //Запрос и его составляющие
        //пример запроса - https://mysite.com/home/index?page=2&info=123

        //В данном примере: https - используемый протокол передачи данных.
        //В данном примере: mysite.com — доменное имя сайта.
        //В данном примере: home — первый сегмент, содержит имя контроллера,
        //index — второй сегмент, содержит имя метода.
        //Сегменты отделяются от параметров запроса символом "вопросительный знак" ("?").

        //После сегментов могут располагаться параметры запроса. 
        //Параметры запроса отделяются друг от друга символом "амперсанд" ("&").
        //Каждый параметр записывается в следующем виде: название параметра=значение параметра


        //URL encoding

        // При написании URL-адреса запроса регистр букв НЕ имеет значения.

        /*
         Есть запрос https://localhost:5001/calc/index?a=1&b=3&c=+ 

        Так как в паре ключ=значение есть +, запрос НЕ будет правильно обработан. 

        Чтобы такой запрос был правильно обработан необходимо символ + закодировать символами %2B. 

        Теперь запрос выглядит https://localhost:5001/calc/index?a=1&b=3&c=%2B. 
        Он корректный и будет  правильно интерпретирован сервером.
         */



        //Шаблон маршрутизации (pattern)

        /*
         В файле Program.cs изначально установлен следующий шаблон маршрутизации:

        app.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
         */


        /*
         В данном шаблоне маршрутизации по умолчанию установлено, что первый сегмент запроса,
        который идет после домена, ASP.NET Core MVC будет определять как имя контроллера ({controller=Home}). 

        Второй сегмент ASP.NET Core MVC будет определять как метод, который находится
        в этом контроллере({action=Index}).

        А третий сегмент будет определять как некий id, который мы сможем использовать,
        например, для передачи данных в метод действия ({id?}).
         */

        //В шаблон маршрутизации мы можем добавлять свои сегменты.
        //pattern: "{controller=Home}/{action=Index}/{a}/{b}"

        /*
         Добавим в метод действия Index() параметры a и b, которые соответствуют названиям сегментов:

        public IActionResult Index(int a, int b)
        {
            return View();
        }

                  
        При получении запроса  https://localhost:7276/home/index/1/2 значения 1 и 2 попадут в метод Index()
        в качестве аргументов и мы сможем эти данные использовать по своему усмотрению.
         */

        //Дополнительные сегменты в шаблоне маршрутизации можно делать
        //опциональными с помощью символа "?" рядом с ними:

        //pattern: "{controller=Home}/{action=Index}/{a?}/{b?}"



        //Представления

        //Представление (View) — это пользовательский интерфейс приложения.
        //Проще говоря, это то, что видит пользователь, внешний вид приложения.

        //Для того чтобы данные выводились в виде представления — веб-страницы с оформлением,
        //используемые методы действия должны возвращать тип данных IActionResult.

        //В ASP.NET Core MVC представления — это файлы с расширением cshtml,
        //которые содержат элементы управления на языке гипертекстовой разметки HTML,
        //а также код на языке программирования C#, то есть в данном файле присутствуют фрагменты кода
        //на обоих языках. Это стало возможным благодаря технологии Razor,
        //которую также называют движком представлений Razor.
        //Все конструкции Razor начинаются с символа @ и позволяют переключаться с языка
        //гипертекстовой разметки HTML на использование языка программирования C#.

        /*
         @{
    ViewData["Title"] = "Home Page";
        }

        <div class="text-center">
            <h1 class="display-4">Welcome</h1>
            <p>Learn about <a href="https://learn.microsoft.com/aspnet/core">building Web apps with ASP.NET Core</a>.</p>
        </div>
         */

        //Как передавать данные из контроллера в представление?
        //Чтобы использовать переданные в представление \Views\Home\Index.cshtml данные,
        //необходимо в самом верху этого файла написать директиву @model и после нее прописать тип данных
        //передаваемой модели (в данном случае – List<Product>):
        /*
         @model List<Product>
        @{
            ViewData["Title"] = "Home Page";
        }

        <div class="text-center">
            <h1 class="display-4">Welcome</h1>
            <p>Learn about <a href="https://learn.microsoft.com/aspnet/core">building Web apps with ASP.NET Core</a>.</p>
        </div>
         */
        //В представление можно передать только одну модель с данными любого типа,
        //то есть в сshtml-файле может быть только одна строка @model тип передаваемых данных. 

        /*
         Для вывода списка всех товаров используем оператор foreach в конструкции @{}, для перехода на язык C#:

        @foreach (var product in Model)
        {
            @product
        }
         */

        //HTML + CSS


        //Заголовки (заголовочные теги)
        /*
         Заголовок H1 имеет самый большой шрифт, это заголовок первого уровня. Обычно он единственный на странице.

        Заголовки H2 – H6 помогают разбивать текст на логические блоки.
         */

        //<h1>Текст.</h1>


        //Параграфы - Используются для оформления текстового абзаца, начинаются с новой строки,
        // отделяются от остального контента отступами сверху и снизу.

        //Параграфы – парные теги, то есть они имеют как открывающий, так и закрывающий тег.
        //Между ними находится текст параграфа.
        //<p>Текст.</p>

        //Перевод строки
        //Текст<br>текст.


        //Ссылки

        /*
         Используются для создания гиперссылок.
        Гиперссылки — это ссылки, которые позволяют связать текст или картинку с другим HTML-документом. 
        При нажатии на ссылку происходит переход по ней.

        Ссылки – парные теги, то есть они имеют как открывающий, так и закрывающий тег.
        Между ними находится текст. При создании ссылки необходимо указать атрибут href="URL", 
        где URL – ссылка на документ или сайт.

        Ссылки бывают внешние и внутренние. Внешние ссылки ведут с нашего сайта на другие файлы 
        (картинки, документы, видео и т.п.) или другие сайты. Внутренние ссылки используют так называемые «якоря»,
        это когда мы можем ссылаться на определенные блоки на странице, обращаясь к ним через идентификаторы.
       */

        //<a href="URL">Текст.</a>

        //При написании данной ссылки используется полный путь,
        //то есть абсолютный, ссылка позволит перейти на внешний сайт:
        //<a href="http://ya.ru">

        /*
         При написании данной ссылки используется относительный путь
        (в нашем случае этот путь относительно домена localhost), 
        ссылка позволит перейти в нашем проекте на страницу конкретного товара:
        <a href="/product/index/1">
         */

        //Изображения

        //<img src=”URL”>
        //<img src="https://ped-kopilka.ru/upload/blogs2/2024/7/47_f85ae7c371cae7ab0299fa8c28957d75.jpg.jpg" width="10%">

        //<img src = "flowers.png" >


        //Блоки
        /*
         Используются для группировки элементов, определяют разделы или секции в HTML-документе.

        У блоков нет визуального представления на странице, 
        но они позволяют задавать стили оформления для контента внутри себя.
         */
        //<div>…</div>


        //Атрибуты id, class и style в тегах
        //Атрибут style определяет стиль элемента, какие CSS-стили к нему применяются.
        //Благодаря этому атрибуту можно менять различные настройки отображения элементов на странице.
        //Но удобнее и правильнее описывать стили отображения всех элементов,
        //используемых для представлений нашего проекта, в файле \wwwroot\css\cite.css.
        //В этом случае нам необходимо задавать атрибуты id или class для элементов.

        /*
         Атрибуты id и class используются для идентификации и стилизации элементов.

        Атрибут id должен быть уникальным для всей страницы, 
        таким образом мы можем его использовать для стилизации определенного элемента.

        Атрибут class аналогичен атрибуту id, но позволяет применять один и тот же стиль оформления для различных 
        элементов. Имя класса — это имя стиля, который у нас уже есть или который создаем и описываем в файле
        \wwwroot\css\cite.css.
         */



        //Библиотека Bootstrap
        //Bootstrap — это бесплатный HTML-, CSS- и JS-фреймворк с открытым исходным кодом для быстрой вёрстки
        //адаптивных дизайнов сайтов и веб-приложений.
        //Эта библиотека предоставляет разработчикам готовые компоненты и стили,
        //которые можно легко интегрировать в проект, что значительно ускоряет процесс разработки.
        //С помощью Bootstrap можно писать простой и качественный код, который будет понятен другим разработчикам. 

        /*
         Код разметки для вывода данных каждой карточки:

        <div class="card shadow">
            <img class="card-img-top" src=@product.PhotoPath alt="...">
            <div class="card-body text-center">
                <a class="text-success" href="/product/index/@product.Id">
                    <h5>@product.Name</h5>
                </a>
                <h2 class="text-danger">@product.Cost.ToString("c")</h2>
                <a class="btn btn-success" href="#">Добавить в корзину</a>
            </div>
        </div>

                  
        Bootstrap-класс shadow позволяет отрисовать тень вокруг карточки.
        Bootstrap-класс card-body используется для оформления секции внутри карточки.
        Bootstrap-класс text-center позволяет отцентровать текст элемента (в данном случае, блока и ссылки).
        Bootstrap-класс text-success задает зеленый цвет для элемента (в данном случае, ссылки).
        Bootstrap-класс text-danger задает красный цвет для элемента (в данном случае, заголовка).
        Bootstrap-класс btn оформляет ссылку в виде кнопки.
        Bootstrap-класс btn-success задает зеленый цвет для кнопки.
         */

        /*
         Полный листинг представления \Views\Home\Index.cshtml:

        @model List<Product>
        @{
            ViewData["Title"] = "Home Page";
        }


        <div class="row">
            @if (Model != null)
            {
                @foreach (var product in Model)
                {
                    <div class="col-3 mb-3">
                        <div class="card shadow">
                            <img class="card-img-top" src=@product.PhotoPath alt="...">
                            <div class="card-body text-center">
                                <a class="text-success" href="/product/index/@product.Id">
                                    <h5>@product.Name</h5>
                                </a>
                                <h2 class="text-danger">@product.Cost.ToString("c")</h2>
                                <a class="btn btn-success" href="#">Добавить в корзину</a>
                            </div>
                        </div>
                    </div>
                }
            }
            else
            {
                <h2>Нет товаров для отображения!</h2>
            }
        </div>
         */


        //Перенаправление на метод действия

        /*
         Допустим, перед нами стоит задача:
        по входящему запросу типа https://localhost:5001/Product/Add?name=Product6&cost=1750&description=Best
        должно производиться добавление нового товара с характеристиками, переданными в параметрах запроса.

        Для решения данной задачи необходимо:

        реализовать метод Add() в репозитории ProductRepository, 
        реализующий добавление нового товара в список всех товаров;
        добавить кнопку добавления товара в представление \Views\Home\Index.cshtml;
        реализовать метод действия Add() в контроллере ProductController;
        отобразить измененный список товаров в представлении \Views\Home\Index.cshtml.
         */

        //Если после добавления товара выполним return View();, который использовали ранее для вызова
        //соответствующего представления, то произойдет ошибка, так как у нас нет соответствующего представления.
        //Но даже если бы оно было, мы находились бы на странице добавления товара и тогда повторное обращение
        //к ней приводило бы к повторному добавлению товара без отображения новых данных,
        //нам же необходимо добавить товар и перейти на страницу отображения товаров.

        /*
         Таким образом, после того как новый товар добавлен, то есть данные в списке товаров изменились,
        необходимо выполнить отображение актуальных данных. Для этого нужно произвести переадресацию 
        на метод действия, который отвечает за это.
        В нашем случае метод действия Index() в контроллере HomeController отвечает за отображение всех товаров.

        Выполнить перенаправление на метод действия можно с помощью метода RedirectToAction(). 

         */

        /*
         Так как необходимо выполнить переадресацию на метод действия НЕ текущего контроллера
        (текущий контроллер - ProductController, переадресация - в контроллер HomeController),
        то мы используем одну из перегрузок метода RedirectToAction() 
        и передаем в него кроме имени метода действия, также и имя контроллера в виде параметров:

        public IActionResult Add(string name, decimal cost, string description)
        {
            ProductsRepository.Add(name, cost, description);

            return RedirectToAction("Index", "Home");
        }

        Если бы методы действия Add() и Index() относились к одному контроллеру, 
        то в методе RedirectToAction() было бы достаточно указать только имя метода действия
        (в данном случае - "Index")):

        return RedirectToAction("Index");
         */


        //asp-helpers
        /*
         При оформлении ссылок есть следующие особенности:

        когда мы используем конкретные ссылки, типа <a href="/home/index">Главная</a>,
        если поменять шаблон маршрутизации, то придется все ссылки менять,
        но когда ссылки оформлены через asp-хэлперы менять их не придется;
 
        если будет удалена какая-либо секция в шаблоне маршрутизации (не считая первых двух),
        то придется менять ссылки. 
        Например, был шаблон: pattern: "{controller=Home}/{action=Index}/{name}/{id}";
        и использовались ссылки типа 
        <a href="/home/index/recommend/@product.Id">Рекомендуемый товар</a>,
        при изменении шаблона на  
        pattern: "{controller=Home}/{action=Index}/{id}"; необходимо будет изменить все ссылки 
        с учетом данного изменения на <a href="/home/index/@product.Id">Рекомендуемый товар</a>,
        иначе будут ошибки при запросах. Через asp-хэлперы менять ссылки не придется, 
        они сами умеют взаимозаменять сегменты и параметры запроса;

        при оформлении ссылок с использованием asp-хэлперов читаемость кода намного выше.
 
        Все вышесказанное делает очевидным преимущества использования asp-хэлперов.
         */

        /*
         asp-controller	указывает на контроллер, которому предназначен запрос
        asp-action	указывает на действие контроллера
        asp-route-[название параметра]	определяет значение для определенного параметра
         */




        //Dependency Injection
        /*
         Dependency Injection (DI) — это механизм, который позволяет управлять созданием объектов, 
        также называемых сервисами или зависимостями.
        Вместо того чтобы самостоятельно создавать объекты с помощью ключевого слова new,
        механизмы DI берут на себя эту задачу, автоматически создавая нужные объекты и передавая их туда,
        где они необходимы.

        В контексте ASP.NET Core DI-контейнер встроен в фреймворк и значительно упрощает управление зависимостями.
 
        Сервис (Dependency/Service) — это любой класс, экземпляры которого создаются и управляются DI-контейнером.
        Важно, чтобы класс НЕ был статическим.
         */

        /*
         В DI доступны три основных типа жизненного цикла объектов:

        Transient (Временный) — объект создаётся при каждом запросе.
        При каждом вызове сервиса вы получаете новый экземпляр.
        При использовании метода AddTransient() значения отличаются при каждом вызове одного и того же сервиса.
 

        Scoped (Область видимости) — объект создаётся один раз на время одного HTTP-запроса
        и используется повторно во всех местах этого запроса.
        При использовании метода AddScoped() для одного запроса объект сохраняется,
        и все запросы в течение этого времени видят один и тот же экземпляр.
 

        Singleton (Одиночка) — объект создаётся единожды за весь жизненный цикл приложения и используется везде.
        При использовании метода AddSingleton() объект создаётся один раз и остаётся неизменным для всех запросов.
         */


        /*
         Не используйте ключевое слово new для создания сервисов и зависимостей.
        Управление созданием объектов должно полностью осуществляться DI-контейнером.

        Если сервис хранит состояние, его лучше регистрировать с жизненным циклом Singleton.

        Если сервис хранит состояние, связанное только с одним HTTP-запросом,
        то его нужно регистрировать с жизненным циклом Scoped.

        Если сервис не хранит состояние, то можно использовать жизненный цикл Transient.
         */

        /*
         Пример:

        Создать класc-сервис Counter:

        public class Counter
        {
            private static int _value = 0;

            public int Value => _value++; 
        } 

        Регистрация через IServiceCollectionи установка времени жизни сервиса Counter 
        с помощью метода AddTransientв  Program.cs:

        builder.Services.AddTransient<Counter>();

        Внедрение сервиса в нужный класс через его конструктор:

        public class TestController : Controller
        {
            private readonly Counter _counter;

            public TestController(Counter counter)
            {
                _counter = counter;
            }

            public string Index()
            {
                return _counter.Value.ToString();
            }
        }

                  
        Использование в коде значения экземпляра сервиса, сохраненного в поле _counter.
         */



        // Передача данных из представления в контролллер
        /*
         Чтобы отправить данные, которые ввёл пользователь на странице (например, при оформлении заказа)
        на сервер, все элементы ввода input должны быть обёрнуты в тег form. 
        То есть содержимое страницы с полями ввода необходимо заключить в упомянутый тег.

        Тег form - это специальный контейнер, который собирает введенные данные и отправляет их на сервер.

        Тег form парный, то есть имеет как открывающий, так и закрывающий тег. 
        Между ними находится содержимое формы.

        Синтаксис:  

        <form>Содержимое формы</form>

        У тега form есть некоторое число атрибутов.
        На данном этапе разработки нам потребуется указать атрибут method для тега form:

        <form method="метод_отправки_данных">
        Содержимое формы
        </form>
         */
        //Атрибут method — отвечает за метод отправки данных: get или post.
        //Для отправки данных на сервер используется метод post.
        //Метод get применяется, когда нужно запросить данные от сервера (получить),
        //то есть отправить данные клиенту.

        /*
         Например:
        Чтобы получить данные из формы (имя, адрес и телефон покупателя) в методе Buy()
        контроллера OrderController укажем  входные параметры: 

        public IActionResult Buy(string name, string address, string phone)
        {
           ...
        }

        Тогда в форме ввода этих данных в представлении \Views\Order\Index.cshtml
        в каждое поле ввода необходимо добавить атрибут name с соответствующим именем входного
        параметра метода Buy() контроллера OrderController:

        <p>
            <label>Имя</label><br />
            <input type="text" class="w-100" name="name"/>
        </p>
        <p>
            <label>Адрес доставки</label><br />
            <input type="text" class="w-100" name="address"/>
        </p>
        <p>
            <label>Телефон</label><br />
            <input type="tel" class="w-100" name="phone"/>
        </p>

        Для кнопки, которая отправляет данные на сервер, должен быть указан атрибут type="submit", 
        так как это НЕ просто кнопка, а элемент, который отправляет данные формы на сервер.

        В нашем случае такой кнопкой отправки данных на сервер является кнопка Оформить заказ,
        ее код необходимо изменить следующим образом:

        <button class="btn btn-outline-danger" type="submit"
            asp-controller="Order"
            asp-action="Buy">
            Оформить заказ
        </button>
         */

        //Приём данных в контроллере:
        /*
         Метод контроллера, который будет обрабатывать входные данные, должен быть помечен атрибутом [HttpPost] 
        — это указывает на то, что он будет принимать данные при post-запросе. 

        Например:
        Для метода Buy() контроллера OrderController должен быть указан атрибут [HttpPost] : 

        [HttpPost]
        public IActionResult Buy(string name, string address, string phone)
        {
           ...
        } 

        Данные можно принимать:

        либо в виде отдельных параметров (например, string name, string phone, string address), если данных мало;

        либо в виде объекта модели, если данных много. Для этого создаётся класс-модель (например, DeliveryUser),
        в который помещаются все нужные свойства (Name, Phone, Address и т.п.). 

        В методе контроллера в большинстве случаев используют объект модели в качестве входного параметра.
        Имена свойств класса-модели должны совпадать с атрибутами name в полях ввода input,
        тогда все данные из них будут успешно получены в методе контроллера. 
        Такая привязка позволяет получить все данные из формы в объект модели,
        что обеспечивает удобство при работе с ними.
         */


        //Частичные представления
        //Частичные представления — это способ разбить одну большую страницу (представление)
        //на несколько маленьких частей.

        /*
         Частичные представления: 

        НЕ делают запросы к серверу, только вставляют статический HTML-код в нужное место страницы. 
        Это удобно для повторяющихся частей интерфейса;
        подходят только для статических частей интерфейса, которые НЕ изменяются динамически, 
        то есть НЕ получают данные с сервера в момент отображения.
         */

        /*
         Шаги создания частичного представления:

        Создание частичного представления (по соглашению в каталоге \Views\Shared
        или в каталоге конкретного контроллера).

        Добавление необходимого HTML-кода для решения задачи.

        Реализация вызова частичного представления в основном представлении.
         */

        //вызов частичного представления, реализованного нами, производится в этой строке:
        //@await Html.PartialAsync("Header")


        //Компоненты представлений
        /*
         Компонент представления состоит из двух основных частей:

        класс компонента (код на C#);

        представление компонента (файл .cshtml).


        Шаги создания компонента:

        Создание папки для компонентов (по соглашению в каталоге \Views\Shared\Components).

        Создание класса компонента наследованного от ViewComponent. 
        В этом классе реализовать метод Invoke или InvokeAsync для получения данных.

        Создание представления компонента для отображения данных.
         */





        //Валидация данных

        //Валидация на стороне клиента с помощью HTML5 - Обеспечивается с помощью атрибутов тега <input>.
        /*
         Список типов значений для элемента <input>:

        text — однострочное текстовое поле для ввода произвольного текста пользователем;

        password — поле ввода пароля, при котором введённые символы скрываются
        (обычно отображаются точками или звёздочками) для защиты конфиденциальности;

        file — поле для загрузки файлов с локального устройства пользователя на сервер;

        checkbox — флажок, который позволяет пользователю выбрать один или несколько вариантов
        из предложенного набора;

        radio — переключатель, с помощью которого можно выбрать только один вариант из группы взаимосвязанных опций;

        submit — кнопка, при нажатии на которую форма отправляет введённые данные на сервер;

        email — поле для ввода адреса электронной почты со встроенной проверкой корректности формата email;

        tel — поле для ввода телефонного номера, поддерживающее базовую валидацию формата номера;

        url — поле для ввода веб-адреса (URL) с проверкой правильности формата;

        hidden — скрытое поле, не отображаемое пользователю, используемое для передачи служебных данных 
        вместе с формой;

        date — элемент для выбора даты из календаря или ручного ввода в формате даты;

        time — поле для ввода времени (часы и минуты), часто с возможностью выбора из удобного интерфейса;

        number — поле для ввода числовых значений, поддерживающее минимальные, максимальные и шаговые ограничения;

        range — ползунок для выбора значения из заданного диапазона чисел;

        color — поле для выбора цвета с помощью специального цветового селектора;

        month — элемент для выбора месяца и года (например, для указания срока действия карты);

        week — поле для выбора недели в году;

        datetime-local — элемент для выбора даты и времени без учёта временной зоны.
         */

        /*
         Использование атрибутов	Примечание
        <input type="text" name="name" required />	
        Поле обязательно для заполнения. Браузер покажет предупреждение

        <input type="text" name="name" minlength="2" maxlength="25" />	
        Ограничение длины для текстовых полей

        <input type="number" name="age" min="16" max="90" />
        Ограничение для числовых значений. Появятся стрелки "вверх/вниз"

        <input type="email" name="login" />
        <input type="password" name="password" />
        <input type="tel" name="phone" />
        Специальные типы

        <input type="tel" name="phone" pattern="\d{4}-\d{3}-\d{4}" />	Регулярное выражение
         */





        //Валидация на стороне клиента с помощью ASP.NET Core

        //Добавление атрибутов валидации к модели:
        /*
         Атрибут	Описание	Основные параметры
        Required	Обозначает, что поле обязательно должно быть заполнено	AllowEmptyStrings — разрешить пустые строки
        StringLength	Установка максимальной и минимальной длины строки	
        MaximumLength — макс. длина, 

        MinimumLength — мин. длина

        Range	Проверка, что значение числового поля или даты находится в указанном диапазоне	Minimum, Maximum
        RegularExpression	Проверка соответствия значению регулярного выражения (например, формат телефона или email)	Pattern — регулярное выражение
        Compare	Сравнивает значение с другим свойством модели (например, подтверждение пароля)	OtherProperty — имя свойства для сравнения
        EmailAddress	Проверка, что значение представляет корректный email	—
        Phone	Проверка корректности телефонного номера	—
        Url	Проверка, что значение является валидным URL	—
        CreditCard	Проверка номера кредитной карты по формату	—
         */

        //Важные моменты при использовании атрибутов валидации:

        // Типы значений, такие как int, double, DateTime, по умолчанию считаются обязательными,
        // для них не требуется[Required]. Свойства модели таких типов можно пометить как required,
        // либо сделать их Nullable, чтобы избежать предупреждений Microsoft Visual Studio

        /*
         Для строкового свойства модели можно указать параметр AllowEmptyStrings = true в [Required], чтобы оно могло принимать значение null.

        Ошибки валидации можно локализовать через свойства ErrorMessageResourceName и ErrorMessageResourceType.
         */

        /*
         Пример использования атрибутов валидации:

        using System.ComponentModel.DataAnnotations;

        namespace OnlineShopWebApp.Models
        {
            public class Registration
            {
                [Required(ErrorMessage = "Не указано имя")]
                [StringLength(25, MinimumLength = 2, ErrorMessage = "Длина должна быть от {2} до {1} символов")]
                public string Name { get; set; }

                [Required(ErrorMessage = "Не указан возраст")]
                [Range(16, 100, ErrorMessage = "Возраст должен быть от {1} до {2} лет")]
                public int Age { get; set; }

                [Required(ErrorMessage = "Не указан логин")]
                [EmailAddress(ErrorMessage = "Введите валидный email")]
                public string Login { get; set; }

                [Required(ErrorMessage = "Не указан номер телефона")]
                [RegularExpression(@"\d{4}-\d{3}-\d{4}")]
                public string Phone { get; set; }

                [Required(ErrorMessage = "Не указан пароль")]
                public string Password { get; set; }

                [Required(ErrorMessage = "Не указан повторный пароль")]
                [Compare("Password", ErrorMessage = "Пароли не совпадают")]
                public string ConfirmPassword { get; set; }
            }
        }
         */

        //Использование tag-хелперов валидации в представлении.
        /*
         <div>
            <label asp-for="ИМЯ_СВОЙСТВА_КЛАССА_МОДЕЛИ"></label><br />
            <input type="ТИП_СВОЙСТВА_КЛАССА_МОДЕЛИ" asp-for="ИМЯ_СВОЙСТВА_КЛАССА_МОДЕЛИ" />
            <span asp-validation-for="ИМЯ_СВОЙСТВА_КЛАССА_МОДЕЛИ" />
        </div>
         */


        //Пример использования tag-хелперов валидации:
        /*
         @model Registration
        @{
            ViewData["Title"] = "Регистрация пользователя";
        }

        <div class="text-center text-uppercase text-success mb-5 mt-5">
            <h2 class="row-title">Регистрация</h2>
        </div>
        <form method="post">
            <div class="row justify-content-center mt-3">
                <div class="col-6 mb-3">
                    <!-- Поле имени -->
                    <p>
                        <label class="form-label" asp-for="Name"></label>
                        <input class="form-control" asp-for="Name" />
                        <span asp-validation-for="Name"></span>
                    </p>
                    <p>
                        <!-- Поле возраста -->
                        <label class="form-label" asp-for="Age"></label>
                        <input class="form-control" asp-for="Age" />
                        <span asp-validation-for="Age"></span>
                    </p>
                    <p>
                        <!-- Поле логина -->
                        <label class="form-label" asp-for="Login"></label>
                        <input class="form-control" asp-for="Login" />
                        <span asp-validation-for="Login"></span>
                    </p>
                    <p>
                        <!-- Поле пароля -->
                        <label class="form-label" asp-for="Password"></label>
                        <input class="form-control" asp-for="Password" />
                        <span asp-validation-for="Password"></span>
                    </p>
                    <p>
                        <!-- Подтверждение пароля -->
                        <label class="form-label" asp-for="ConfirmPassword"></label>
                        <input class="form-control" asp-for="ConfirmPassword" />
                        <span asp-validation-for="ConfirmPassword"></span>
                    </p>
                </div>
            </div>
            <div class="text-center m-3">
                <button class="btn btn-outline-success" type="submit"
                        asp-controller="Account"
                        asp-action="Registration">
                    Зарегистрироваться
                </button>
            </div>
        </form>
         */
        //Надо принять модельку, в которой прописаны атрибуты валидации!
        //Хоть эта моделька и не передается с метода контроллера! 

        //Подключение скриптов валидации.
        // в Layout:
        //@await Html.PartialAsync("_ValidationScriptsPartial")

        //Использование дополнительных атрибутов при валидации модели
        /*
         Основные свойства атрибута [Display]
        Свойство	Описание
        Name	Задает имя, которое будет показано в <label>или <title>. Используется для отображения вместо имени свойства
        Description	Описание поля, часто используется как подсказка (tooltip)
        Prompt 	Текст-подсказка, который отображается внутри поля ввода (placeholder)
         */
        /*
         public class Registration
        {
            [Display(Name = "Возраст", Prompt = "Ваш возраст")]
            [Required(ErrorMessage = "Не указан возраст")]
            [Range(16, 100, ErrorMessage = "Возраст должен быть от {1} до {2} лет")]
            public int Age { get; set; }

            [Display(Name = "Логин", Prompt = "Ваш логин")]
            [Required(ErrorMessage = "Не указан логин")]
            [EmailAddress(ErrorMessage = "Введите валидный email")]
            public string Login { get; set; }
        }
         */

        /*
         Основные значения атрибута [DataType]
        Значение [DataType]	Описание
        Text	Обычный текст (по умолчанию)
        MultilineText	Многострочный текст, например, textarea
        Password	Поле ввода пароля, символы скрыты
        EmailAddress	Адрес электронной почты с валидацией
        PhoneNumber	Телефонный номер
        Url	Веб-адрес
        Date	Дата без времени
        Time	Время без даты
        DateTime	Полная дата и время
        Currency	Денежная сумма
        CreditCard	Номер кредитной карты
        PostalCode	Почтовый индекс
         */

        /*
         public class Registration
        {
            [Display(Name = "Логин", Prompt = "Ваш логин")]
            [Required(ErrorMessage = "Не указан логин")]
            [EmailAddress(ErrorMessage = "Введите валидный email")]
            [DataType(DataType.EmailAddress)]
            public string Login { get; set; }

            [Required(ErrorMessage = "Не указан пароль")]
            [DataType(DataType.Password)]
            public string Password { get; set; }
        }
         */

        /*
         Атрибут [ValidateNever] запрещает системе валидации проверять данное свойство или параметр. 
        Если атрибут применён к свойству модели, это свойство игнорируется при проверке на корректность. 
        Если применён к параметру контроллера, этот параметр не проверяется автоматической валидацией модели.
        Если применён к типу, все свойства этого типа не проходят проверку.
         */


        //Реализация собственного класса валидации данных
        /*
         using System.ComponentModel.DataAnnotations;

        namespace OnlineShopWebApp.Helpers
        {
            public class DateRangeAttribute : ValidationAttribute
            {
                private readonly DateOnly minDate;
                private readonly DateOnly maxDate;

                public DateRangeAttribute()
                {
                    minDate = DateOnly.FromDateTime(DateTime.Now);
                    maxDate = DateOnly.FromDateTime(DateTime.Now.AddMonths(3));

                    if (string.IsNullOrEmpty(ErrorMessage))
                        ErrorMessage = $"Дата должна быть от {minDate.ToShortDateString()} до {maxDate.ToShortDateString()}";
                }

                protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
                {
                    if (value == null)
                        return new ValidationResult(ErrorMessage);
                
                    var date = DateOnly.FromDateTime((DateTime)value);

                    if (date < minDate || date > maxDate)
                        return new ValidationResult(ErrorMessage);
            
                    return ValidationResult.Success;
                }
            }
        }

         */
        /*
         [Display(Name = "Дата доставки")]
        [Required(ErrorMessage = "Не указана дата доставки")]        
        [DataType(DataType.Date)]
        [DateRange]
        public DateTime Date { get; set; }
         */





        //Валидация данных на сервере

        //Валидация данных на сервере обязательна в каждом приложении, даже при наличии клиентской валидации.

        //Обеспечивается через использование ModelState. ModelState.IsValid проверяет атрибуты модели.
        /*
         [HttpPost]
        public IActionResult Registration(Registration registration)
        {
            // Проверка валидности
            if (!ModelState.IsValid)
            {
                // Возврат View с моделью (сохраняются ошибки и данные)
                return View(registration);
            }

            // Обработка валидных данных
            // Сохранение в БД, отправка email и т.д.

            // Редирект ТОЛЬКО после успешной обработки
            return RedirectToAction("Success");
        }
         */

        //Вывод ошибок клиенту:
        //<div asp-validation-summary="ТИП_ВЫВОДА_ОШИБОК"></div>
        /*
         Типы вывода ошибок в asp-validation-summary
        Значение	Примечание
        All	Все ошибки (модели и свойств)
        ModelOnly	Только ошибки уровня модели
        None	Не показывать ошибки
         */

        //Пример:
        /*
         
        @model Registration
        @{
            ViewData["Title"] = "Регистрация пользователя";
        }

        <div class="text-center text-uppercase text-success mb-5 mt-5">
            <h2 class="row-title">Регистрация</h2>
        </div>
        <form method="post">
            <div class="row justify-content-center mt-3">
                <div class="col-6 mb-3">
                    <!-- Вывод общих ошибок модели -->
                    <div asp-validation-summary="ModelOnly"></div>
                    <!-- Поле имени -->
                    <p>
                        <label class="form-label" asp-for="Name"></label>
                        <input class="form-control" asp-for="Name" />
                        <span asp-validation-for="Name"></span>
                    </p>
                    <p>
                        <!-- Поле возраста -->
                        <label class="form-label" asp-for="Age"></label>
                        <input class="form-control" asp-for="Age" />
                        <span asp-validation-for="Age"></span>
                    </p>
                    <p>
                        <!-- Поле логина -->
                        <label class="form-label" asp-for="Login"></label>
                        <input class="form-control" asp-for="Login" />
                        <span asp-validation-for="Login"></span>
                    </p>
                    <p>
                        <!-- Поле пароля -->
                        <label class="form-label" asp-for="Password"></label>
                        <input class="form-control" asp-for="Password" />
                        <span asp-validation-for="Password"></span>
                    </p>
                    <p>
                        <!-- Подтверждение пароля -->
                        <label class="form-label" asp-for="ConfirmPassword"></label>
                        <input class="form-control" asp-for="ConfirmPassword" />
                        <span asp-validation-for="ConfirmPassword"></span>
                    </p>
                </div>
            </div>
            <div class="text-center m-3">
                <button class="btn btn-outline-success" type="submit"
                        asp-controller="Account"
                        asp-action="Registration">
                    Зарегистрироваться
                </button>
            </div>
        </form>
        */

        //Валидация данных и RedirectToAction()
        /*
         При использовании RedirectToAction() или других методов редиректа валидация и ошибки теряются, 
        поскольку происходит новый HTTP запрос, и ModelState не сохраняется.
 
        Почему валидация "слетает" при редиректе:

        Новый HTTP запрос: Редирект создаёт новый запрос.

        Потеря ModelState: Состояние модели не передаётся между запросами.

        Потеря данных формы: Введённые пользователем данные теряются.
         */
        /*
         [HttpPost]
        public IActionResult Registration(Registration registration)
        {
            //Дополнительная валидация
            if (/* какие-то условия /*)
            {
                ModelState.AddModelError("поле", "сообщение об ошибке");
            }

            // Проверка валидности
            if (!ModelState.IsValid)
            {
                // Возврат View с моделью (сохраняются ошибки и данные)
                return View(registration);
        }

        // Обработка валидных данных
        // Сохранение в БД, отправка email и т.д.

        // Редирект ТОЛЬКО после успешной обработки
        return RedirectToAction("Success");
        }
         */





        //Логирование данных

        //Библиотека Serilog
        /*
         
        Установка необходимых пакетов для использования библиотеки логирования:

        Для подключения Serilog необходимо установить следующие NuGet-пакеты:

        Serilog — основная библиотека;

        Serilog.AspNetCore — интеграция с ASP.NET Core;

        Serilog.Enrichers.Environment — для работы с окружением;

        Serilog.Enrichers.Process — информация о процессах;

        Serilog.Enrichers.Thread — информация о потоках;

        Serilog.Settings.Configuration — чтение настроек из конфигурации.
         */

        //Основные настройки Serilog
        /*
         Настройка	Описание
        WriteTo	
        Определяет, куда записывать логи:

        Console — вывод в консоль

        File — сохранение в файл

        Для File настройки:

        path — путь к файлу логов

        rollingInterval: "Day" — создание нового файла каждый день (предотвращает создание слишком больших файлов)

        formatter — формат JSON для структурированного хранения



        Enrich 	Дополнительная информация в каждом логе:
        Название компьютера

        ID процесса

        ID потока

        Контекст логирования



        MinimumLevel	Определяет, какие логи записывать:
        При разработке: Information (все логи)

        На продакшене: Error (только ошибки)
 

        Уровни логирования:

        Debug — отладочная информация

        Information — общая информация

        Warning — предупреждения

        Error — ошибки

        Critical — критические ошибки
         */


        /*
         Идентификация запросов в JSON файле

        RequestId, SpanId, TraceId помогают отслеживать путь запроса через приложение:

        Запрос приходит в контроллер

        Контроллер вызывает сервис

        Сервис обращается к репозиторию

        Репозиторий работает с базой данных

        Все логи одного запроса имеют одинаковый RequestId, что позволяет легко найти все связанные записи.
         */

        /*
         Практические рекомендации использования библиотеки логирования:

        в режиме Development (разработка): используйте уровень Information для получения максимальной детализации отчетов;

        в режиме Production (продакшен): используйте уровень Error или Warning для экономии места;

        обязательно указывайте название приложения ApplicationName, если в компании несколько проектов;

        используйте ротацию файлов Rolling files по дням для предотвращения создания огромных логов;

        структурированные логи JSON легче анализировать автоматически.
         */


        #endregion
    }
}
